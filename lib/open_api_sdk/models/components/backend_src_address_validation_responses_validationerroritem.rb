# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module OpenApiSDK
  module Models
    module Components
    

      class BackendSrcAddressValidationResponsesValidationErrorItem
        extend T::Sig
        include Crystalline::MetadataFields

        # Type of validation error
        field :type, ::String, { 'format_json': { 'letter_case': ::OpenApiSDK::Utils.field_name('type'), required: true } }
        # Location of error
        field :loc, T::Array[::String], { 'format_json': { 'letter_case': ::OpenApiSDK::Utils.field_name('loc'), required: true } }
        # Error message
        field :msg, ::String, { 'format_json': { 'letter_case': ::OpenApiSDK::Utils.field_name('msg'), required: true } }
        # Invalid input value
        field :input, ::Object, { 'format_json': { 'letter_case': ::OpenApiSDK::Utils.field_name('input'), required: true } }
        # Additional context
        field :ctx, T::Hash[Symbol, ::Object], { 'format_json': { 'letter_case': ::OpenApiSDK::Utils.field_name('ctx'), required: true } }

        sig { params(type: ::String, loc: T::Array[::String], msg: ::String, input: ::Object, ctx: T::Hash[Symbol, ::Object]).void }
        def initialize(type:, loc:, msg:, input:, ctx:)
          @type = type
          @loc = loc
          @msg = msg
          @input = input
          @ctx = ctx
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          T.cast(other, BackendSrcAddressValidationResponsesValidationErrorItem)
          return false unless @type == other.type
          return false unless @loc == other.loc
          return false unless @msg == other.msg
          return false unless @input == other.input
          return false unless @ctx == other.ctx
          true
        end
      end
    end
  end
end
